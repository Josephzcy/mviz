// Generated by gencpp from file mviz_apa_show/RCFusion.msg
// DO NOT EDIT!


#ifndef MVIZ_APA_SHOW_MESSAGE_RCFUSION_H
#define MVIZ_APA_SHOW_MESSAGE_RCFUSION_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <mviz_apa_show/SingleTarget.h>

namespace mviz_apa_show
{
template <class ContainerAllocator>
struct RCFusion_
{
  typedef RCFusion_<ContainerAllocator> Type;

  RCFusion_()
    : timestamp(0)
    , tick(0)
    , frame_id(0)
    , counter(0)
    , track_num(0)
    , fusion_list()
    , isValid(false)  {
    }
  RCFusion_(const ContainerAllocator& _alloc)
    : timestamp(0)
    , tick(0)
    , frame_id(0)
    , counter(0)
    , track_num(0)
    , fusion_list(_alloc)
    , isValid(false)  {
  (void)_alloc;
    }



   typedef uint64_t _timestamp_type;
  _timestamp_type timestamp;

   typedef uint64_t _tick_type;
  _tick_type tick;

   typedef uint32_t _frame_id_type;
  _frame_id_type frame_id;

   typedef uint32_t _counter_type;
  _counter_type counter;

   typedef uint32_t _track_num_type;
  _track_num_type track_num;

   typedef std::vector< ::mviz_apa_show::SingleTarget_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::mviz_apa_show::SingleTarget_<ContainerAllocator> >::other >  _fusion_list_type;
  _fusion_list_type fusion_list;

   typedef uint8_t _isValid_type;
  _isValid_type isValid;





  typedef boost::shared_ptr< ::mviz_apa_show::RCFusion_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mviz_apa_show::RCFusion_<ContainerAllocator> const> ConstPtr;

}; // struct RCFusion_

typedef ::mviz_apa_show::RCFusion_<std::allocator<void> > RCFusion;

typedef boost::shared_ptr< ::mviz_apa_show::RCFusion > RCFusionPtr;
typedef boost::shared_ptr< ::mviz_apa_show::RCFusion const> RCFusionConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mviz_apa_show::RCFusion_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::mviz_apa_show::RCFusion_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::mviz_apa_show::RCFusion_<ContainerAllocator1> & lhs, const ::mviz_apa_show::RCFusion_<ContainerAllocator2> & rhs)
{
  return lhs.timestamp == rhs.timestamp &&
    lhs.tick == rhs.tick &&
    lhs.frame_id == rhs.frame_id &&
    lhs.counter == rhs.counter &&
    lhs.track_num == rhs.track_num &&
    lhs.fusion_list == rhs.fusion_list &&
    lhs.isValid == rhs.isValid;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::mviz_apa_show::RCFusion_<ContainerAllocator1> & lhs, const ::mviz_apa_show::RCFusion_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace mviz_apa_show

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::mviz_apa_show::RCFusion_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mviz_apa_show::RCFusion_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mviz_apa_show::RCFusion_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mviz_apa_show::RCFusion_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mviz_apa_show::RCFusion_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mviz_apa_show::RCFusion_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::mviz_apa_show::RCFusion_<ContainerAllocator> >
{
  static const char* value()
  {
    return "27f1ca61f681b113259a02b5b2446af5";
  }

  static const char* value(const ::mviz_apa_show::RCFusion_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x27f1ca61f681b113ULL;
  static const uint64_t static_value2 = 0x259a02b5b2446af5ULL;
};

template<class ContainerAllocator>
struct DataType< ::mviz_apa_show::RCFusion_<ContainerAllocator> >
{
  static const char* value()
  {
    return "mviz_apa_show/RCFusion";
  }

  static const char* value(const ::mviz_apa_show::RCFusion_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::mviz_apa_show::RCFusion_<ContainerAllocator> >
{
  static const char* value()
  {
    return "    #header.gnssStamp\n"
"	uint64 timestamp                              # UTC时戳, 微秒\n"
"    #header.timestamp\n"
"	uint64 tick                                   # 异构设备上的时钟, 微秒\n"
"    uint32 frame_id                               # 融合对应的图像帧号\n"
"    #header.seq\n"
"    uint32 counter                                # 融合计数，判断融合是否更新\n"
"    #ObjAmount\n"
"	uint32 track_num                              # 融合目标数量\n"
"    #fusionOut\n"
"    SingleTarget[] fusion_list             # 融合目标信息\n"
"    bool isValid\n"
"================================================================================\n"
"MSG: mviz_apa_show/SingleTarget\n"
"#ObjectID\n"
"uint32 id                                      #->trackID # 目标ID\n"
"\n"
"# /*\n"
"# \"目标的融合维护状态：\n"
"#define TRACK_STATUS_NEW 2                         ->2(New)                                                   \n"
"#define TRACK_STATUS_NEW_COASTED 3                 ->3(new Coasted)\n"
"#define TRACK_STATUS_NEW_UPDATED_RADAR 4           ->4(new updated)\n"
"#define TRACK_STATUS_NEW_UPDATED_CAMERA 5          ->4(new updated)\n"
"#define TRACK_STATUS_COASTED 6                     ->6(Coasted)\n"
"#define TRACK_STATUS_UPDATED_RADAR 9               ->5(updated)\n"
"#define TRACK_STATUS_UPDATED_MUL_RADAR 10          ->5(updated)\n"
"#define TRACK_STATUS_UPDATED_CAMERA 11             ->5(updated)\n"
"#define TRACK_STATUS_UPDATED_BOTH 12               ->5(updated)\n"
"#define TRACK_STATUS_INVALID 0                     ->0(invalid)\n"
"#define TRACK_STATUS_MERGE 7                       ->1(Merged)\n"
"#define TRACK_STATUS_MERGE_BY_FRONT_VIEW 8         ->0(invalid)\n"
"# */\n"
"#MaintenanceStatus\n"
"uint32 status                                  # 目标更新状态\n"
"\n"
"# /*\n"
"# \"目标运动状态：\n"
"#define TRACK_DYNP_UNKNOWN 0                      ->0xf(notavailable)\n"
"#define TRACK_DYNP_STATIONARY 1                   ->0(stationary)\n"
"#define TRACK_DYNP_ONCOMING 2                     ->3(oncoming)\n"
"#define TRACK_DYNP_MOVING 3                       ->2(moving)\n"
"#define TRACK_DYNP_ONCOMING_FAST 4                ->3(oncoming)\n"
"#define TRACK_DYNP_MOVING_FAST 5                  ->2(moving)\n"
"# */\n"
"#MotionPattern\n"
"uint32 movement                                # 目标运动状态\n"
"\n"
"# /*\n"
"# 障碍物类别:\n"
"# const int32_t kVehicleClassNegative = 0;          ->0(undetermined)\n"
"# const int32_t kVehicleClassCar = 1;               ->1(car)\n"
"# const int32_t kVehicleClassMiniBus = 2;           ->1(car)\n"
"# const int32_t kVehicleClassBus = 3;               ->3(bus)\n"
"# const int32_t kVehicleClassTruck = 4;             ->4(boxtruck)\n"
"# const int32_t kVehicleClassSpecial = 5;           ->5(special car)\n"
"# const int32_t kVehicleClassCnt = 6;               ->0(undetermined)\n"
"# const int32_t kCyclist = 7;                       ->7(bicycle)\n"
"# const int32_t kPedestrian = 8;                    ->6(Pedestrian)\n"
"\n"
"# */\n"
"#Class\n"
"uint32 object_class                           # 目标分类\n"
"\n"
"#AccelerationAbs.y\n"
"float32 accel_lat_obj                         #->accel_lat_obj   # 目标横向加速度\n"
"\n"
"uint32 vis_track_id                         #->vis_track_id # 关联到视觉目标ID\n"
"uint32 radar_track_id                       #  # 关联的雷达目标ID\n"
"\n"
"#RectInfo.SizeLWH.y\n"
"float32 width                                 #->Width  # 目标宽度\n"
"\n"
"#ExistenceProbability\n"
"float32 confidence                            #->confidence  # 目标置信度\n"
"\n"
"bool cipv                                   #->把cipv为true的track设置到0x400报文中  # 目标是否是关键目标        \n"
"\n"
"#VelocityAbs.x\n"
"float32 v_long_obj                            #->v_long_obj   # 目标纵向速度\n"
"\n"
"#VelocityAbs.y\n"
"float32 v_lat_obj                             #->v_lat_obj   # 目标横向速度\n"
"\n"
"float32 l_long_rel                            #->l_long_rel   # 目标纵向距离(参考点)\n"
"\n"
"float32 l_lat_rel                             #->l_lat_rel   # 目标横向距离（参考点）\n"
"\n"
"# /*\n"
"# 在当前的融合Cycle内，探测到该目标的传感器：\n"
"# Bit0:Radar Front\n"
"# Bit1:Radar FrontLeft\n"
"# Bit2:Radar FrontRight\n"
"# Bit3:Radar RearLeft\n"
"# Bit4:Radar RearRight\n"
"# Bit9:Camera FrontWideAngle\n"
"# Bit10:Camera Rear\n"
"# Bit13:Camera LeftForwardLooking\n"
"# Bit14:Camera LeftBackwardLooking\n"
"# Bit17:Camera RightForwardLooking\n"
"# Bit18:Camera RightBackwardLooking\n"
"# */\n"
"# /*\n"
"# 以下只针对1v1r\n"
"# 只有bit0->1(single tracklet);\n"
"# 只有bit9->3(vision only);\n"
"# 同时有bit0和bit9->4(tracklet and vison)\n"
"# 其他情况则均为0        \n"
"# */\n"
"#DetectSensor_Current\n"
"uint32 detection_sensor                        # 目标由哪个传感器更新\n"
"\n"
"#AccelerationAbs.x\n"
"float32 accel_long_obj                           #->accel_long_obj # 目标纵向加速度\n"
"\n"
"#RectInfo.SizeLWH.x\n"
"float32 length                                   #->length # 目标长度\n"
"\n"
"#RectInfo.Orientation\n"
"float32 heading_angle                              #->heading_angle # 目标航向角\n"
"\n"
"# RadarFrame asso_radar\n"
"# CameraFrame asso_camera \n"
"# /*\n"
"# \"在目标的生命周期内，曾经探测到该目标的传感器。\n"
"# 位域的定义同detection_sensor。\"\n"
"# */\n"
"#DetectSensor_History\n"
"uint32 DetectSensor_History                    \n"
"\n"
"# /*\n"
"# \"讨论结果：如果OBJ是Radar Only OBJ时,后续讨论类别置信度输出问题\n"
"# ==>直接赋值100，很危险，所以请Minieye使用更为合理的方式评估。\"\n"
"# */\n"
"float32 ClassConfidence\n"
"# /*\n"
"# 障碍物被识别的时间戳,us\n"
"# */\n"
"uint64 TimeCreation\n"
"# /*\n"
"# 障碍物最近更新时间,us\n"
"# */\n"
"uint64 LastUpdatedTime\n"
"# /*\n"
"# \"记载当该目标被某Sensor识别时，Sensor赋予它的ID号。\n"
"# 数组大小32，排序方法与上方DetectSensor使用的位域排序方法一致。预留的元素均填“0”\"\n"
"# */\n"
"uint32[] SensorID\n"
"# /*\n"
"# \"目标历史运动状态：\n"
"# */\n"
"uint32 MotionPatternHistory\n"
"# /*\n"
"# \"刹车灯的状态：\n"
"# 0-Unknow\n"
"# 1-Off\n"
"# 2-On\"\n"
"# */\n"
"uint32 BrakeLightSt\n"
"# /*\n"
"# \"转向信号灯状态：\n"
"# 0-Unknow\n"
"# 1-Off\n"
"# 2-Left_Flash\n"
"# 3-Right_Flash\n"
"# 4-Left_and_rihgt_Flash\"\n"
"# */\n"
"uint32 TurnLightSt\n"
"# /*\n"
"# \"近边，即传感器探测的目标的面。\n"
"# 0-FRONT;\n"
"# 1-REAR;\n"
"# 2-RIGHTSIDE;\n"
"# 3-LEFTSIDE;\"\n"
"# */\n"
"uint32 NearSide                                 #->Target_pos\n"
"\n"
"FusionRect3D RectInfo\n"
"\n"
"float32 OrientationStdDev\n"
"\n"
"float32 ttc\n"
"\n"
"uint32 lane_id\n"
"\n"
"uint32 tsl_id\n"
"\n"
"uint32 cut_state\n"
"\n"
"float32 collip_prob\n"
"================================================================================\n"
"MSG: mviz_apa_show/FusionRect3D\n"
"geometry_msgs/Point Center\n"
"geometry_msgs/Point CenterStdDev\n"
"geometry_msgs/Point SizeLWH\n"
"geometry_msgs/Point SizeStdDev\n"
"geometry_msgs/Point[] Corners\n"
"================================================================================\n"
"MSG: geometry_msgs/Point\n"
"# This contains the position of a point in free space\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
;
  }

  static const char* value(const ::mviz_apa_show::RCFusion_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::mviz_apa_show::RCFusion_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.timestamp);
      stream.next(m.tick);
      stream.next(m.frame_id);
      stream.next(m.counter);
      stream.next(m.track_num);
      stream.next(m.fusion_list);
      stream.next(m.isValid);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RCFusion_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::mviz_apa_show::RCFusion_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::mviz_apa_show::RCFusion_<ContainerAllocator>& v)
  {
    s << indent << "timestamp: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.timestamp);
    s << indent << "tick: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.tick);
    s << indent << "frame_id: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.frame_id);
    s << indent << "counter: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.counter);
    s << indent << "track_num: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.track_num);
    s << indent << "fusion_list[]" << std::endl;
    for (size_t i = 0; i < v.fusion_list.size(); ++i)
    {
      s << indent << "  fusion_list[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::mviz_apa_show::SingleTarget_<ContainerAllocator> >::stream(s, indent + "    ", v.fusion_list[i]);
    }
    s << indent << "isValid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isValid);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MVIZ_APA_SHOW_MESSAGE_RCFUSION_H
